#pragma once

#include <Eigen/Dense>

#include "solid_3d_object.h"
#include "MT_Quaternion.h"

namespace bmpf {
    /**
     * @brief Базовый класс для всех коллайдеров
     * Базовый класс для всех коллайдеров, все функции
     * являются чисто виртуальными
     * Коллайдер выстраивает параметризированную сцену, состоящую
     * из произвольного числа роботов, потом по состоянию
     * возвращает флаг, соответствует ли это состояние коллизии моделей
     * сцены. Состояния передаются в качестве матриц преобразований
     * из текущей СК звена в следующую.
     * Класс работает по следующему принципу: сначала мы задаём
     * состояние кооллайдеру, а потом либо запускаем его рисование, либо
     * проверку коллизий, одновременно эти два дейсвтвия выполняться не могут.
     * При этом он оперирует только 3D объектами и их матрицами преобразований
     */
    class Collider {
    public:
        /**
         * инициализация коллайдера
         *
         * @param groupedModelPaths вектор векторов путей к моделям. это связано с тем,
         * что сцена строится на основе набора описаний роботов
         * каждый из них содержит список путей к своим моделям
         * @param subColliders флаг, нудно ли составить виртуальные сцены для
         * каждого подмножества объектов сцены
         */
        virtual void init(std::vector<std::vector<std::string>> groupedModelPaths, bool subColliders) = 0;

        /**
         * рисование сцены коллайдера
         * @param matrices список матриц преобразования из текущей
         * СК звена в следующую
         * @param onlyRobot флаг, нужно ли рисовать только роботов
         * или ещё и статические объекты сцены
         */
        virtual void paint(std::vector<Eigen::Matrix4d> matrices, bool onlyRobot) = 0;

        /**
         * проверка соответствует ли состояние сцены столкновению
         * @param matrices список матриц преобразований звеньев
         * @return флаг, соответствует ли состояние сцены столкновению
         */
        virtual bool isCollided(std::vector<Eigen::Matrix4d> matrices) = 0;

        /**
         * @brief проверка соответствует ли состояние сцены столкновению
         * проверка соответствует ли состояние сцены (список матриц преобразований звеньев
         * только для задействованных объектов)
         * столкновению при этом учитываются только объекты с индексами из robotIndexes
         * @param matrices список матриц преобразований звеньев
         * @param robotIndexes индексы роботов
         * @return флаг, соответствует ли состояние сцены столкновению
         */
        virtual bool isCollided(std::vector<Eigen::Matrix4d> matrices, std::vector<int> robotIndexes) = 0;

        /**
         * возвращает список всех координат полигона (вектор нормали и координаты вершины):
         * nx, ny, nz, ax, ay, az, bx, by, bz, cx, cy, cz по списку матриц состояния
         * @param matrices список матриц преобразований звеньев
         * @return возвращает список всех координат полигона
         */
        virtual std::vector<float> getPoints(std::vector<Eigen::Matrix4d> matrices) = 0;

        /**
         * @brief  получить координаты куба, ограничивающего объём робота
         * получить координаты куба, ограничивающего объём, в котором
         * помещён робот с индексом robotNum, если задать его звеньям
         * матрицы трансформации из списка всех матриц трансформации
         * звеньев сцены, возвращает список из шести координат:
         * min.x(), min.y(), min.z(), max.x(), max.y(), max.z()
         * @param robotNum номер робота в списке роботов
         * @param matrices список матриц преобразований звеньев
         * @return получить координаты куба, ограничивающего объём робота
         */
        virtual std::vector<double> getBoxCoords(unsigned long robotNum, std::vector<Eigen::Matrix4d> matrices) = 0;

        /**
         * @brief получить точки куба, ограничивающего объём робота
         * получить точки куба, ограничивающего объём, в котором
         * помещён робот с индексом robotNum, если задать его звеньям
         * матрицы трансформации из списка всех матриц трансформации
         * звеньев сцены, возвращает список из точек,
         * по которым построится куб линиями GL_LINES
         * ax, ay, az, bx, by, bz
         * @param robotNum номер робота в списке роботов
         * @param matrices список матриц преобразований звеньев
         * @return получить точки куба, ограничивающего объём робота
         */
        virtual std::vector<double> getBoxPoints(unsigned long robotNum, std::vector<Eigen::Matrix4d> matrices) = 0;


    };


}